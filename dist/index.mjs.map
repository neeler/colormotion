{"version":3,"sources":["../src/Theme.ts","../src/ColorPalette.ts","../src/InterpolationMode.ts","../src/mapRange.ts","../src/mapBrightnessToDarkenFactor.ts","../src/safeMod.ts"],"sourcesContent":["import chroma, { Color } from 'chroma-js';\nimport { ColorInput, ColorPalette } from './ColorPalette';\nimport { InterpolationMode, InterpolationModes } from './InterpolationMode';\nimport { mapBrightnessToDarkenFactor } from './mapBrightnessToDarkenFactor';\nimport { safeMod } from './safeMod';\n\nexport interface ThemeConfig {\n    /**\n     * The number of steps in the color scale.\n     * Defaults to 2048.\n     */\n    nSteps?: number;\n    /**\n     * The color interpolation mode to use between colors in the palette.\n     * Defaults to RGB.\n     */\n    mode?: InterpolationMode;\n    /**\n     * The initial colors in the palette.\n     * Defaults to red, green, and blue.\n     */\n    colors?: ColorInput[];\n    /**\n     * The minimum threshold for the CIEDE2000 color distance between colors in the palette.\n     * Defaults to 20.\n     */\n    deltaEThreshold?: number;\n    /**\n     * A callback function to call when the theme is updated.\n     */\n    onUpdate?: (colors: string[]) => void | Promise<void>;\n}\n\ninterface ColorUpdateConfig {\n    /**\n     * The speed of the transition between two palettes.\n     */\n    transitionSpeed?: number;\n}\n\n/**\n * A dynamic color theme that can be updated and transitioned between different color palettes.\n */\nexport class Theme {\n    readonly nSteps: number;\n    /**\n     * The active palette to use for color generation.\n     */\n    palette: ColorPalette;\n    /**\n     * The target palette to transition to.\n     */\n    targetPalette?: ColorPalette;\n    private _brightness = 255;\n    /**\n     * The interpolation mode to use between colors in the palette.\n     */\n    mode: InterpolationMode;\n    private transitionSpeed = 0;\n    private iColor = 0;\n    private previousColorDistance?: number;\n    private readonly colorDistanceThreshold = 0.001;\n    private colors: Color[];\n\n    constructor(private readonly config?: ThemeConfig) {\n        this.nSteps = this.config?.nSteps ?? 2048;\n        this.mode = this.config?.mode ?? InterpolationModes.rgb;\n        this.palette = new ColorPalette({\n            colors: this.config?.colors ?? ['red', 'green', 'blue'],\n            mode: this.mode,\n            nSteps: this.nSteps,\n            deltaEThreshold: this.config?.deltaEThreshold,\n        });\n        this.colors = this.palette.scaleColors;\n    }\n\n    private get scale() {\n        return this.palette.scale;\n    }\n\n    /**\n     * The active palette to use for color generation.\n     */\n    get activePalette() {\n        return this.targetPalette ?? this.palette;\n    }\n\n    /**\n     * The hex values of the colors in the active palette.\n     */\n    get activePaletteHexes() {\n        const hexes = this.activePalette.hexes;\n        hexes.pop();\n        return hexes;\n    }\n\n    /**\n     * The relative brightness of the theme.\n     */\n    get brightness() {\n        return this._brightness;\n    }\n\n    /**\n     * Set the relative brightness of the theme.\n     */\n    set brightness(brightness: number) {\n        this._brightness = Math.max(1, Math.min(255, brightness));\n    }\n\n    private getBaseColor(index = 0) {\n        const baseColor = this.colors[this.normalizeIndex(index)] as Color;\n        if (this._brightness === 255) {\n            return baseColor;\n        }\n        return baseColor.darken(mapBrightnessToDarkenFactor(this._brightness));\n    }\n\n    /**\n     * Get the color at the given index in the theme.\n     * @param index The index of the color to get.\n     * @param options Options for the color generation.\n     * @param options.brightness Optionally adjust the brightness of the color. 0-255, defaults to 255.\n     * @returns The color at the given index.\n     */\n    getColor(index = 0, { brightness = 255 }: { brightness?: number } = {}) {\n        const color = this.getBaseColor(index);\n        if (brightness === 255) {\n            return color;\n        }\n        return color.darken(mapBrightnessToDarkenFactor(brightness));\n    }\n\n    /**\n     * Update the theme to a new set of colors.\n     *\n     * transitionSpeed should be between (0,1)\n     */\n    private updateScale(\n        targetPalette: ColorPalette,\n        { transitionSpeed = 0.1 }: ColorUpdateConfig = {},\n    ) {\n        if (targetPalette === this.palette) {\n            this.clearTargetPalette();\n            return;\n        }\n        if (targetPalette === this.targetPalette) {\n            return;\n        }\n        this.mode = targetPalette.mode;\n        this.transitionSpeed = Math.min(1, Math.max(0, transitionSpeed)) / 10;\n        this.targetPalette = targetPalette;\n        this.config?.onUpdate?.(this.targetPalette.hexes);\n    }\n\n    /**\n     * Update the theme to a new set of colors, steps, and interpolation mode.\n     */\n    update(\n        {\n            colors,\n            nSteps,\n            mode,\n        }: {\n            colors: ColorInput[];\n            mode: InterpolationMode;\n            nSteps: number;\n        },\n        options?: ColorUpdateConfig,\n    ) {\n        this.updateScale(\n            this.activePalette.newConfig({\n                colors,\n                nSteps,\n                mode,\n            }),\n            options,\n        );\n    }\n\n    /**\n     * Set the interpolation mode of the theme.\n     */\n    setMode(\n        mode: InterpolationMode = InterpolationModes.rgb,\n        options?: ColorUpdateConfig,\n    ) {\n        this.updateScale(this.activePalette.newMode(mode), options);\n    }\n\n    /**\n     * Rotate the interpolation mode of the theme.\n     */\n    rotateMode(options?: ColorUpdateConfig) {\n        this.updateScale(this.activePalette.rotateMode(), options);\n    }\n\n    /**\n     * Set the colors of the theme.\n     */\n    setColors(colorInputs: ColorInput[], options?: ColorUpdateConfig) {\n        this.updateScale(this.activePalette.newColors(colorInputs), options);\n    }\n\n    /**\n     * Randomize the colors of the theme based on a seed color.\n     */\n    randomFrom(\n        color: ColorInput,\n        {\n            minBrightness = 0,\n            ...options\n        }: ColorUpdateConfig & {\n            minBrightness?: number;\n        },\n    ) {\n        this.updateScale(\n            this.activePalette.randomizeFrom(color, {\n                minBrightness,\n            }),\n            options,\n        );\n    }\n\n    /**\n     * Randomize the colors of the theme.\n     */\n    randomTheme(options?: ColorUpdateConfig) {\n        this.updateScale(this.activePalette.randomize(), options);\n    }\n\n    /**\n     * Get the color at the given index in the theme.\n     * Rounds and normalizes the index so that it is within the bounds of the color scale.\n     */\n    normalizeIndex(index = 0) {\n        let normalizedIndex = Math.round(index);\n        return (\n            safeMod(normalizedIndex + this.iColor, this.nSteps) % this.nSteps\n        );\n    }\n\n    /**\n     * Push a new color to the end of the palette.\n     */\n    pushNewColor(color: ColorInput, options?: ColorUpdateConfig) {\n        this.updateScale(this.activePalette.push(color), options);\n    }\n\n    /**\n     * Push a random color to the end of the palette.\n     */\n    pushRandomColor(options?: ColorUpdateConfig) {\n        this.updateScale(this.activePalette.pushRandom(), options);\n    }\n\n    /**\n     * Pop the oldest color from the palette.\n     */\n    popOldestColor(options?: ColorUpdateConfig) {\n        this.updateScale(this.activePalette.popOldest(), options);\n    }\n\n    /**\n     * Drops the oldest color and pushes the new color.\n     */\n    rotateColor(color: ColorInput, options?: ColorUpdateConfig) {\n        this.updateScale(this.activePalette.rotateOn(color), options);\n    }\n\n    /**\n     * Drops the oldest color and pushes a random color.\n     */\n    rotateRandomColor(options?: ColorUpdateConfig) {\n        this.updateScale(this.activePalette.rotateRandomOn(), options);\n    }\n\n    private clearTargetPalette() {\n        this.targetPalette = undefined;\n        this.previousColorDistance = undefined;\n    }\n\n    /**\n     * Move the color index by n steps.\n     * Can be negative to move backwards.\n     */\n    tick(n = 1) {\n        if (this.targetPalette) {\n            if (this.targetPalette === this.palette) {\n                this.clearTargetPalette();\n            } else {\n                const targetColors = this.targetPalette.scaleColors;\n                const colorDistances = targetColors.map((color, iColor) =>\n                    chroma.deltaE(color, this.colors[iColor] as Color, 1, 1, 1),\n                );\n                const averageColorDistance =\n                    colorDistances.reduce((sum, d) => sum + d, 0) /\n                    colorDistances.length;\n                if (\n                    this.previousColorDistance !== undefined &&\n                    Math.abs(\n                        this.previousColorDistance - averageColorDistance,\n                    ) < this.colorDistanceThreshold\n                ) {\n                    this.palette = this.targetPalette;\n                    this.colors = this.palette.scaleColors;\n                    this.clearTargetPalette();\n                } else {\n                    this.previousColorDistance = averageColorDistance;\n                    this.colors = this.colors.map((baseColor, iColor) =>\n                        chroma(\n                            chroma.mix(\n                                baseColor,\n                                targetColors[iColor] as Color,\n                                this.transitionSpeed,\n                                this.mode,\n                            ),\n                        ),\n                    );\n                }\n            }\n        }\n\n        this.iColor += n;\n    }\n}\n","import chroma, { Color, Scale } from 'chroma-js';\nimport { RequireExactlyOne } from 'type-fest';\nimport {\n    InterpolationMode,\n    getNextInterpolationMode,\n} from './InterpolationMode';\n\n/**\n * String or chroma-js color.\n */\nexport type ColorInput = string | Color;\n\nexport type ColorPaletteConfig = RequireExactlyOne<{\n    /**\n     * The colors to use in the palette.\n     */\n    colors: ColorInput[];\n    /**\n     * The normalized colors to use in the palette.\n     */\n    normalizedColors: Color[];\n}> & {\n    /**\n     * The interpolation mode to use between colors in the palette.\n     */\n    mode: InterpolationMode;\n    /**\n     * The number of steps in the color scale.\n     */\n    nSteps: number;\n    /**\n     * The minimum threshold for the CIEDE2000 color distance between colors in the palette.\n     * Defaults to 20.\n     */\n    deltaEThreshold?: number;\n};\n\n/**\n * An immutable ColorPalette.\n */\nexport class ColorPalette {\n    readonly colors: chroma.Color[];\n    readonly hexes: string[];\n    readonly key: string;\n    readonly nColors: number;\n    readonly mode: InterpolationMode;\n    readonly nSteps: number;\n    readonly scale: Scale;\n    readonly scaleColors: Color[];\n    private readonly maxNumberOfColors = 8;\n    private readonly deltaEThreshold: number;\n\n    /**\n     * Normalizes the input colors to chroma-js colors.\n     */\n    static normalizeColors(colorInputs: ColorInput[]) {\n        const colors = colorInputs.map((value) => chroma(value));\n\n        // Ensure that the palette has colors\n        const firstColor = colors[0] ?? chroma('green');\n        colors[0] = firstColor;\n\n        const firstHex = firstColor.hex();\n        const lastHex = colors[colors.length - 1]?.hex();\n\n        // Ensure that we don't already have a color loop\n        if (colors.length > 1 && firstHex === lastHex) {\n            colors.pop();\n        }\n\n        // Ensure that wheel loops back to first color\n        colors.push(firstColor);\n\n        return colors;\n    }\n\n    private static analyzeColors(colors: ColorInput[]) {\n        const normalizedColors = ColorPalette.normalizeColors(colors);\n        const key = normalizedColors.map((c) => c.hex()).join(':');\n\n        return {\n            key,\n            normalizedColors,\n        };\n    }\n\n    constructor({\n        colors,\n        mode,\n        nSteps,\n        normalizedColors,\n        deltaEThreshold,\n    }: ColorPaletteConfig) {\n        this.mode = mode;\n        this.nSteps = nSteps;\n        this.colors = normalizedColors ?? ColorPalette.normalizeColors(colors);\n\n        // Don't count the duplicate color at the end of the wheel\n        this.nColors = this.colors.length - 1;\n\n        this.hexes = this.colors.map((c) => c.hex());\n        this.key = this.hexes.join(':');\n\n        this.scale = chroma\n            .scale(this.colors)\n            .mode(mode)\n            .domain([0, nSteps])\n            .out(null);\n        const scaleColors = this.scale.colors(nSteps + 1).map((c) => chroma(c));\n        scaleColors.pop();\n        this.scaleColors = scaleColors;\n        this.deltaEThreshold = deltaEThreshold ?? 20;\n    }\n\n    /**\n     * Creates a new palette with the specified configuration.\n     */\n    newConfig({\n        colors,\n        nSteps,\n        mode,\n    }: {\n        colors: ColorInput[];\n        mode: InterpolationMode;\n        nSteps: number;\n    }) {\n        const modeIsSame = mode === this.mode;\n        const nStepsIsSame = nSteps === this.nSteps;\n\n        if (modeIsSame && nStepsIsSame) {\n            return this.newColors(colors);\n        }\n\n        const { key, normalizedColors } = ColorPalette.analyzeColors(colors);\n        const colorsAreSame = key === this.key;\n\n        if (nStepsIsSame && colorsAreSame) {\n            return this.newMode(mode);\n        }\n\n        return new ColorPalette({\n            mode,\n            nSteps,\n            normalizedColors,\n        });\n    }\n\n    /**\n     * Gets a new palette with new colors but the same mode.\n     */\n    newColors(colors: ColorInput[]) {\n        const { key, normalizedColors } = ColorPalette.analyzeColors(colors);\n\n        if (key === this.key) {\n            return this;\n        }\n\n        return new ColorPalette({\n            mode: this.mode,\n            nSteps: this.nSteps,\n            normalizedColors,\n        });\n    }\n\n    /**\n     * Gets a new palette with the same colors but a different mode.\n     */\n    newMode(mode: InterpolationMode) {\n        if (mode === this.mode) {\n            return this;\n        }\n\n        return new ColorPalette({\n            colors: this.colors,\n            mode,\n            nSteps: this.nSteps,\n        });\n    }\n\n    /**\n     * Gets a new palette with the same colors but the next mode.\n     */\n    rotateMode() {\n        return this.newMode(getNextInterpolationMode(this.mode));\n    }\n\n    /**\n     * Randomizes the palette starting with the input color.\n     *\n     * @param seed The color to start with.\n     * @param options Options for randomizing the palette.\n     * @param options.minBrightness The minimum brightness for the colors.\n     * @returns A new palette with randomized colors.\n     */\n    randomizeFrom(\n        seed: ColorInput,\n        {\n            minBrightness = 0,\n        }: {\n            minBrightness?: number;\n        } = {},\n    ) {\n        let lastColor = seed;\n        const colors = [seed];\n        let attempts = 0;\n        while (colors.length < this.nColors && attempts < 10) {\n            const possibleColor = chroma.random();\n            if (\n                chroma.deltaE(lastColor, possibleColor, 1, 1, 1) >\n                    this.deltaEThreshold &&\n                possibleColor.get('hsv.v') > minBrightness\n            ) {\n                colors.push(possibleColor);\n                lastColor = possibleColor;\n            }\n            attempts += 1;\n        }\n        while (colors.length < this.nColors) {\n            colors.push(chroma.random());\n        }\n\n        return this.newColors(colors);\n    }\n\n    /**\n     * Randomizes the whole palette with a random number of colors.\n     */\n    randomize(nColors = Math.floor(Math.random() * 3 + 3)) {\n        let lastColor = chroma.random();\n        const colors = [lastColor];\n        let attempts = 0;\n        while (colors.length < nColors && attempts < 10) {\n            const possibleColor = chroma.random();\n            if (\n                chroma.deltaE(lastColor, possibleColor, 1, 1, 1) >\n                this.deltaEThreshold\n            ) {\n                colors.push(possibleColor);\n                lastColor = possibleColor;\n            }\n            attempts += 1;\n        }\n        while (colors.length < nColors) {\n            colors.push(chroma.random());\n        }\n\n        return this.newColors(colors);\n    }\n\n    /**\n     * Adds the specified color.\n     */\n    push(color: ColorInput) {\n        if (this.nColors >= this.maxNumberOfColors) {\n            return this;\n        }\n\n        return this.newColors(this.colors.concat(chroma(color)));\n    }\n\n    /**\n     * Adds a random color.\n     */\n    pushRandom() {\n        return this.push(chroma.random());\n    }\n\n    /**\n     * Drops the oldest color.\n     */\n    popOldest() {\n        if (this.nColors < 2) {\n            return this;\n        }\n\n        const oldestColor = this.hexes[0];\n        return this.newColors(\n            this.hexes.reduce((colors, hex) => {\n                if (hex !== oldestColor) {\n                    colors.push(chroma(hex));\n                }\n                return colors;\n            }, Array<Color>()),\n        );\n    }\n\n    /**\n     * Drops the oldest color and pushes the new color.\n     */\n    rotateOn(color: ColorInput) {\n        const newColors: ColorInput[] = [\n            ...this.hexes.slice(1, this.hexes.length - 1),\n            color,\n        ];\n        return this.newColors(newColors);\n    }\n\n    /**\n     * Drops the oldest color and adds a random color.\n     */\n    rotateRandomOn() {\n        const lastColor = this.colors[this.colors.length - 1] as Color;\n        let newColor;\n        let attempts = 0;\n        while (!newColor && attempts < 10) {\n            const possibleColor = chroma.random();\n            if (chroma.deltaE(lastColor, possibleColor, 1, 1, 1) > 20) {\n                newColor = possibleColor;\n            }\n            attempts += 1;\n        }\n        return this.rotateOn(newColor ?? chroma.random());\n    }\n}\n","/**\n * Supported interpolation modes.\n */\nexport const InterpolationModes = {\n    rgb: 'rgb',\n    lab: 'lab',\n    lrgb: 'lrgb',\n    hsl: 'hsl',\n    lch: 'lch',\n    hsv: 'hsv',\n    hsi: 'hsi',\n    hcl: 'hcl',\n} as const;\n\nexport type InterpolationMode =\n    (typeof InterpolationModes)[keyof typeof InterpolationModes];\n\n/**\n * Array of interpolation modes.\n */\nconst InterpolationModeArray = [\n    InterpolationModes.rgb,\n    InterpolationModes.lab,\n    InterpolationModes.lrgb,\n    InterpolationModes.hsl,\n    InterpolationModes.lch,\n    InterpolationModes.hsv,\n    InterpolationModes.hsi,\n    InterpolationModes.hcl,\n] as const;\n\n/**\n * Get the next interpolation mode.\n */\nexport function getNextInterpolationMode(mode: InterpolationMode) {\n    const index = InterpolationModeArray.indexOf(mode);\n    return InterpolationModeArray[\n        (index + 1) % InterpolationModeArray.length\n    ] as InterpolationMode;\n}\n","/**\n * The function should be a single-arg function that expects values in the range [0,1]\n * and returns a corresponding value in the same range.\n */\nexport function mapRange({\n    fn = (x: number) => x,\n    inRange = [0, 1],\n    outRange,\n}: {\n    fn?: (xInOriginalRange: number) => number;\n    inRange?: [number, number];\n    outRange: [number, number];\n}) {\n    const inWidth = inRange[1] - inRange[0];\n    const outWidth = outRange[1] - outRange[0];\n\n    return (value: number) => {\n        const valueInOriginalRange = fn((value - inRange[0]) / inWidth);\n        return outRange[0] + outWidth * valueInOriginalRange;\n    };\n}\n","import { mapRange } from './mapRange';\n\n/**\n * Maps a brightness value (1-255) to a darken factor (3-0).\n */\nexport const mapBrightnessToDarkenFactor = mapRange({\n    inRange: [1, 255],\n    outRange: [3, 0],\n});\n","/**\n * Returns the number n, modulo the modulus. The result is always non-negative.\n */\nexport function safeMod(n: number, modulus: number) {\n    return ((n % modulus) + modulus) % modulus;\n}\n"],"mappings":"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","names":["chroma","chroma"]}